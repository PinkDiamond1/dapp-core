import { Buffer } from 'buffer';
import * as bitcoin from 'bitcoinjs-lib';
import BIP32Factory from 'bip32';
import ecc from '@bitcoinerlab/secp256k1';
import { stringToBuffer } from '@/utils/string';
import { ExternalProvider, Web3Provider } from '@ethersproject/providers';
import { arrayify } from '@ethersproject/bytes';
import { keccak256 } from '@ethersproject/keccak256';
import { DEFAULT_ERROR_MESSAGE } from '@/constants/error';

bitcoin.initEccLib(ecc);
const bip32 = BIP32Factory(ecc);

const toXOnly = (pubKey: Buffer): Buffer => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));

const DEFAULT_PATH = "m/86'/0'/0'/0/0";
const SIGN_MESSAGE =
  'Sign this message to generate your Bitcoin Taproot key. This key will be used for your Trustless Computer transactions.';

export const genMetamaskMessageForSign = (payload: {
  taprootAddress: string;
  segwitAddress: string;
  nonceMessage: string;
}) => {
  return `GM.\n\nPlease sign this message to confirm your Trustless Computer wallet addresses generated by your Ethereum address.\n\nTaproot address:\n${payload.taprootAddress}\n\nSegwit address:\n${payload.segwitAddress}\n\nNonce:\n${payload.nonceMessage}\n\nThe Trustless Computer Core Team`;
};

interface IError {
  message: string;
  code: number;
}

const getError = (error: unknown): IError => {
  const randomCode = Math.floor(Math.random() * 100);
  let _err: IError;
  if (typeof error === 'string') {
    _err = {
      message: error,
      code: randomCode,
    };
  } else if (!!error && typeof error === 'object' && 'message' in error && typeof Object(error).message === 'string') {
    const errCode =
      'code' in error && (typeof Object(error).code === 'number' || typeof Object(error).code === 'string')
        ? Object(error).code
        : randomCode;
    _err = {
      message: Object(error).message,
      code: Number(errCode),
    };
  } else {
    _err = {
      message: JSON.stringify(error || DEFAULT_ERROR_MESSAGE),
      code: randomCode,
    };
  }
  return _err;
};

export const isAuthMetamaskError = async (error: unknown, profileAddress: string) => {
  const provider = new Web3Provider(window.ethereum as ExternalProvider);
  let currentAccount;
  const accounts = await provider.send('eth_requestAccounts', []);
  if (!!accounts && !!accounts.length) {
    currentAccount = accounts[0];
    // force re-sign in
    if (!!error && !!currentAccount && currentAccount !== profileAddress) {
      const _err = getError(error);
      return _err.code === 4100;
    }
  }
  return false;
};

export const generateBitcoinTaprootKey = async (address: string) => {
  const provider = new Web3Provider(window.ethereum as ExternalProvider);
  const toSign = '0x' + stringToBuffer(SIGN_MESSAGE).toString('hex');
  const signature = await provider.send('personal_sign', [toSign, address.toString()]);
  const seed = arrayify(keccak256(arrayify(signature)));
  const root = bip32.fromSeed(Buffer.from(seed));

  // Taproot
  const taprootChild = root.derivePath(DEFAULT_PATH);
  const { address: taprootAddress } = bitcoin.payments.p2tr({
    internalPubkey: toXOnly(taprootChild.publicKey),
  });

  return {
    root,
    taprootChild,
    address: taprootAddress,
    signature,
  };
};
